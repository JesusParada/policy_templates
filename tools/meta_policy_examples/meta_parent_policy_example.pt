name "Example Parent Meta Policy (AWS Bucket Tracker)"
rs_pt_ver 20180301
type "policy"
short_description "Tracks buckets info for a given sts role"
long_description "Applied Bucket Tracker updated to delete self if applied as a meta child policy and the meta parent policy has terminated"
severity "low"
category "Meta Policy Testing"
tenancy "single"
default_frequency "15 minutes"
info(
  version: "1.0",
)

parameter "param_days_back" do
  type "string"
  label "Billing Center Days Back"
  description "The number of days you want to look back when getting billing center. More days equals more likely to get good day, but also longer for removed accounts to disappear."
  default "7"
end

parameter "param_rbd_name" do
  type "string"
  label "Rule Based Dimension Filter Name"
  description "The name of the filter being used to determine which AWS accounts the policy should be run in."
  default "rbd_meta_policy_test"
end

parameter "param_rbd_value" do
  type "string"
  label "Rule Based Dimension Filter Value"
  description "The value of the filter being used to determine which AWS accounts the policy should be run in."
  default "staging"
end

## Child Policy Paramters
# We can set enums depending on the policy or just enforce it run at a certain frequency depending on the child policy
# We also want to run this policy at a different freqency than the child policies so we can spread out their run time.
parameter "param_frequency" do
  label "how often the child policies should run"
  type "string"
  allowed_values ["15 minutes", "hourly", "daily", "monthly"]
  default "15 minutes"
end

# This validates the credential exists in this account and gives us the expected format that we pass to the child policies.
credentials "auth_aws" do
  schemes "aws", "aws_sts"
  label "aws"
  tags "provider=aws"
  description "Test replacing aws_account_number"
end

auth "auth_rs", type: "rightscale"

# policy_created_by_id
# Get the Billing Center IDs the customer has access to
datasource "ds_get_billing_centers" do
  request do
    auth $auth_rs
    host rs_optima_host
    path join(["/analytics/users/", policy_created_by_id, "/orgs/", rs_org_id, "/billing_centers"])
    header "Api-Version", "0.1"
  end
end

script "js_make_request", type: "javascript" do
  parameters "rs_org_id", "rs_optima_host", "billing_centers_unformatted", "daysBack", "param_rbd_name", "param_rbd_value"
  result "request"
  code <<-EOS

  billing_centers_formatted = []

  for (x=0; x< billing_centers_unformatted.length; x++) {
    billing_centers_formatted.push(billing_centers_unformatted[x]["id"])
  }

  finish = new Date()
  finishFormatted = finish.toJSON().split("T")[0]
  start = new Date()
  start.setDate(start.getDate()-daysBack)
  startFormatted = start.toJSON().split("T")[0]

  var body = {
    "dimensions":["vendor_account", "vendor_account_name", param_rbd_name],
    "granularity":"day",
    "start_at": startFormatted,
    "end_at": finishFormatted,
    "metrics":["cost_amortized_unblended_adj"],
    "billing_center_ids": billing_centers_formatted,
    "filter":{"dimension":param_rbd_name, "type":"equal", "value":param_rbd_value},
    "summarized": true
  }
  var request = {
    auth:  'auth_rs',
    host:  rs_optima_host,
    scheme: 'https',
    verb: 'POST',
    path:  "/bill-analysis/orgs/"+ rs_org_id + "/costs/aggregated",
    headers: {
      "API-Version": "1.0",
      "Content-Type":"application/json"
    },
    body: JSON.stringify(body)
  }
  EOS
end

# Get the AWS acounts
datasource "ds_get_aws_accounts" do
  request do
    run_script $js_make_request, rs_org_id, rs_optima_host, $ds_get_billing_centers, $param_days_back, $param_rbd_name, $param_rbd_value
  end
  result do
    encoding "json"
    collect jmes_path(response,"rows[*]") do
      field "aws_account_id", jmes_path(col_item,"dimensions.vendor_account")
      field "aws_account_name", jmes_path(col_item,"dimensions.vendor_account_name")
    end
  end
end

# Get Policy itself
datasource "ds_policy_creds_and_last_update" do
  request do
    auth $auth_rs
    host rs_governance_host
    path join(["/api/governance/projects/", rs_project_id, "/applied_policies/", policy_id])
    header "Api-Version", "1.0"
  end
  result do
    encoding "json"
    field "credentials", jmes_path(response, "credentials")
    field "updated_at", jmes_path(response, "updated_at")
  end
end

# Get Child policies
datasource "ds_get_existing_policies" do
  request do
    auth $auth_rs
    host rs_governance_host
    path join(["/api/governance/projects/", rs_project_id, "/applied_policies"])
    header "Api-Version", "1.0"
    query "meta_policy_id", policy_id
  end
  result do
    collect jq(response, '.items[]?') do
      field "name", jq(col_item, ".name")
      field "applied_policy_id", jq(col_item, ".id")
      field "options", jq(col_item, ".options")
      field "updated_at", jq(col_item, ".updated_at")
      field "status", jq(col_item, ".status")
    end
  end
end


datasource "ds_format_existing_policies" do
  run_script $js_format_existing_policies, $ds_get_existing_policies, $ds_format_incidents
end

# format
# duplicates logic should compare updated at
script "js_format_existing_policies", type: "javascript" do
  parameters "unformatted", "incidents"
  result "result"
  code <<-EOS

  result = {}
  formatted = {}
  duplicates = []
  tracking = {}

  for (x=0; x<unformatted.length; x++) {
    aws_account_id=""
    for (y=0;y<unformatted[x].options.length; y++) {
      if (unformatted[x].options[y].name=="param_aws_account_number") {
        aws_account_id= unformatted[x].options[y].value;
      }
    }
    if (formatted[aws_account_id] == undefined) {
      formatted[aws_account_id] = {
        "applied_policy_id":unformatted[x]["applied_policy_id"],
        "applied_policy_name":unformatted[x]["name"],
        "status":unformatted[x]["status"],
        "updated_at":unformatted[x]["updated_at"],
        "incident": incidents[unformatted[x]["applied_policy_id"]]
      }
      tracking[aws_account_id] = false
    } else {
      current = formatted[aws_account_id]

      currDate = new Date(current.updated_at)
      newDate = new Date(unformatted[x].updated_at)

      if (currDate > newDate) {
        duplicates.push({
          "applied_policy_id":unformatted[x]["applied_policy_id"],
          "applied_policy_name":unformatted[x]["name"],
          "status":unformatted[x]["status"],
          "updated_at":unformatted[x]["updated_at"],
          "incident": incidents[unformatted[x]["applied_policy_id"]]
        })
      } else {
        duplicates.push({
          "applied_policy_id":current["applied_policy_id"],
          "applied_policy_name":current["name"],
          "status":current["status"],
          "updated_at":current["updated_at"],
          "incident": current["incident"]
        })
        formatted[aws_account_id] = {
          "applied_policy_id":unformatted[x]["applied_policy_id"],
          "applied_policy_name":unformatted[x]["name"],
          "status":unformatted[x]["status"],
          "updated_at":unformatted[x]["updated_at"],
          "incident": incidents[unformatted[x]["applied_policy_id"]]
        }

      }
    }
  }

  result.formatted=formatted
  result.duplicates=duplicates
  result.tracking=tracking
  EOS
end

# Get Child policies incidents
datasource "ds_get_existing_policies_incidents" do
  request do
    auth $auth_rs
    host rs_governance_host
    path join(["/api/governance/projects/", rs_project_id, "/incidents"])
    header "Api-Version", "1.0"
    query "meta_policy_id", policy_id
  end
  result do
    collect jq(response, '.items[]?') do
      field "incident_id", jq(col_item, ".id")
      field "applied_policy_id", jq(col_item, ".applied_policy.id")
      field "state", jq(col_item, ".state")
      field "violation_data_count", jq(col_item, ".violation_data_count")
      field "updated_at", jq(col_item, ".updated_at")
    end
  end
end

datasource "ds_format_incidents" do
  run_script $js_format_existing_policies_incidents, $ds_get_existing_policies_incidents
end

script "js_format_existing_policies_incidents", type: "javascript" do
  parameters "unformatted"
  result "formatted"
  code <<-EOS
  formatted={}
  for (x=0;x<unformatted.length; x++) {
    current = unformatted[x]
    formatted[current.applied_policy_id] = {incident_id: current.incident_id, state: current.state, violation_data_count: current.violation_data_count, updated_at: current.updated_at}
  }
  EOS
end


datasource "ds_take_in_parameters" do
  run_script $js_take_in_parameters, $ds_get_aws_accounts, $ds_policy_creds_and_last_update, $ds_format_existing_policies, $param_frequency, policy_id, f1_app_host, rs_org_id, rs_project_id
end

# hardcode template href with id from catalog
# catalog policies show in customer's published templates with their org id
script "js_take_in_parameters", type: "javascript" do
  parameters "aws_account_ids", "policy_creds_and_last_update", "existing_policies", "child_frequency", "meta_policy_id", "f1_app_host", "rs_org_id", "rs_project_id"
  result "grid_and_cwf"
  code <<-EOS

  grid_and_cwf={grid:[], to_create:[], to_update:[], to_delete:[]}

  should_keep = existing_policies.tracking

  function add_to_grid(ep, action) {
    policy_status={
      "policy_name": ep["applied_policy_name"],
      "policy_link": "https://" + f1_app_host + "/orgs/" + rs_org_id + "/policy/projects/" + rs_project_id + "/applied-policies/" + ep["applied_policy_id"],
      "meta_policy_status": action,
      "policy_status": ep["status"],
      "policy_last_update": ep["updated_at"],
    }
    if (ep.incident != null) {
      policy_status["incident_link"] = "https://" + f1_app_host + "/orgs/" + rs_org_id + "/policy/projects/" + rs_project_id + "/incidents/" + ep.incident.incident_id
      policy_status["incident_state"] = ep.incident.state
      policy_status["incident_violation_data_count"] = ep.incident.violation_data_count
      policy_status["incident_last_update"] = ep.incident.updated_at
    }
    grid_and_cwf.grid.push(policy_status)
  }

  for (x=0; x<existing_policies.duplicates.length; x++) {
    grid_and_cwf.to_delete.push({"id":existing_policies.duplicates[x]["applied_policy_id"], "name": existing_policies.duplicates[x]["applied_policy_name"]})
    add_to_grid(existing_policies.duplicates[x], "terminating")
  }


  for (x=0; x<aws_account_ids.length; x++) {
    cur = aws_account_ids[x]
    if (existing_policies.formatted[cur.aws_account_id] == undefined) {
      name = "Bucket Tracking for: " + cur.aws_account_name
      options = [
        {
            "name": "param_email",
            "value": []
        },
        {
            "name": "param_aws_account_number",
            "value": cur.aws_account_id
        }
      ]
      grid_and_cwf.to_create.push({
        "name" : name,
        "credentials" : policy_creds_and_last_update.credentials,
        "options" : options,
        "frequency" : child_frequency,
        "meta_policy_id": meta_policy_id,
        "template_href": "/api/governance/orgs/" + rs_org_id + "/published_templates/62618616e3dff80001572bf0"
      })
      policy_status={
        "policy_name": name,
        "policy_link": "",
        "meta_policy_status": "creating policy",
        "policy_status": "",
        "policy_last_update": "",
      }
      grid_and_cwf.grid.push(policy_status)
    } else {
      should_keep[cur.aws_account_id]= true

      parentUpdate = new Date(policy_creds_and_last_update.updated_at)
      curUpdate = new Date(existing_policies.formatted[cur.aws_account_id].updated_at)

      if (parentUpdate > curUpdate) {
        add_to_grid(existing_policies.formatted[cur.aws_account_id], "updating")
        name = "Bucket Tracking for: " + existing_policies.formatted[cur.aws_account_id].aws_account_name
        options = [
          {
              "name": "param_email",
              "value": []
          },
          {
              "name": "param_aws_account_number",
              "value": existing_policies.formatted[cur.aws_account_id].aws_account_id
          }
        ]
        grid_and_cwf.to_update.push({
          "applied_policy_id": existing_policies.formatted[cur.aws_account_id].applied_policy_id,
          "name" : name,
          "credentials" : policy_creds_and_last_update.credentials,
          "options" : options,
          "frequency" : child_frequency,
        })
      } else {
        add_to_grid(existing_policies.formatted[cur.aws_account_id], "running")
      }
    }
  }

  for (key in should_keep) {
    if (!should_keep[key]) {
      grid_and_cwf.to_delete.push({"id":existing_policies.formatted[key].applied_policy_id, "name": existing_policies.formatted[key].applied_policy_name})
      add_to_grid(existing_policies.formatted[key], "terminating")
    }
  }

  EOS
end

datasource "ds_only_grid" do
  run_script $js_only_grid, $ds_take_in_parameters
end

script "js_only_grid", type: "javascript" do
  parameters "results"
  result "only_grid"
  code <<-EOS
    only_grid = results.grid
  EOS
end

datasource "ds_to_create" do
  run_script $js_only_create, $ds_take_in_parameters
end

script "js_only_create", type: "javascript" do
  parameters "results"
  result "only_create"
  code <<-EOS
    only_create = results.to_create
  EOS
end

datasource "ds_to_update" do
  run_script $js_only_update, $ds_take_in_parameters
end

script "js_only_update", type: "javascript" do
  parameters "results"
  result "only_update"
  code <<-EOS
    only_update = results.to_update
  EOS
end

datasource "ds_to_delete" do
  run_script $js_only_delete, $ds_take_in_parameters
end

script "js_only_delete", type: "javascript" do
  parameters "results"
  result "only_delete"
  code <<-EOS
    only_delete = results.to_delete
  EOS
end


# Summary and a conditional incident which will show up if any policy is being applied, updated or deleted.
# Minimum of 1 incident, max of four
# Could swap the summary to only showing running
# Could also just have one incident and use meta_status to determine which esclation happens
policy "policy_scheduled_report" do
  validate $ds_only_grid do
    summary_template "Status of Child Policies"
    export do
      field "policy_name" do
        label "Policy Name"
      end
      field "policy_link" do
        label "Policy Link"
      end
      field "meta_policy_status" do
        label "Meta Status"
      end
      field "policy_status" do
        label "Policy Status"
      end
      field "policy_last_update" do
        label "Policy Last Update"
      end
      field "incident_link" do
        label "Link to Incident"
      end
      field "incident_state" do
        label "Incident State"
      end
      field "incident_violation_data_count" do
        label "Incident Violation Data Count"
      end
      field "incident_last_update" do
        label "Incident Last Update"
      end
    end
    check false
  end
  validate $ds_to_create do
    summary_template "Policies being created"
    escalate $create_policies
    export do
      field "name" do
        label "Name"
      end
      field "credentials" do
        label "Credentials"
      end
      field "options" do
        label "Options"
      end
      field "frequency" do
        label "Frequency"
      end
      field "meta_policy_id" do
        label "Meta Policy ID"
      end
      field "template_href" do
        label "Template Href"
      end
    end
    check eq(size(data),0)
  end
  validate $ds_to_update do
    summary_template "Policies being updated"
    escalate $update_policies
    export do
      field "applied_policy_id" do
        label "Policy ID"
      end
      field "name" do
        label "Name"
      end
      field "credentials" do
        label "Credentials"
      end
      field "options" do
        label "Options"
      end
      field "frequency" do
        label "Frequency"
      end
    end
    check eq(size(data),0)
  end
  validate $ds_to_delete do
    summary_template "Policies being deleted"
    escalate $delete_policies
    export do
      field "id" do
        label "Policy ID"
      end
      field "name" do
        label "Name"
      end
    end
    check eq(size(data),0)
  end
end

escalation "create_policies" do
  run "create_applied_policies", data, rs_governance_host, rs_project_id
end

# if name !=null
define create_applied_policies($data, $governance_host, $rs_project_id) return $responses do
 if $param_alert_options != "Email"
    $responses = []
    foreach $item in $data do
      $response = http_request(
        verb: "post",
        https: true,
        host: $governance_host,
        href: join(["/api/governance/projects/", $rs_project_id, "/applied_policies"]),
        headers: { "Api-Version": "1.0" },
        body: {
          "name": $item["name"],
          "template_href": $item["template_href"],
          "frequency": $item["frequency"],
          "options": $item["options"],
          "credentials": $item["credentials"],
          "meta_policy_id": $item["meta_policy_id"]
        }
      )
      $responses << $response
    end
  end
end

escalation "update_policies" do
  run "update_applied_policies", data, rs_governance_host
end

define update_applied_policies($data, $governance_host) return $responses do
 if $param_alert_options != "Email"
    $responses = []
    foreach $item in $data do
      $response = http_request(
        verb: "patch",
        https: true,
        host: $governance_host,
        href: join(["/api/governance/projects/", $rs_project_id, "/applied_policies/", $item["applied_policy_id"]]),
        headers: { "Api-Version": "1.0" },
        body: {
          "name": $item["name"],
          "frequency": $item["frequency"],
          "options": $item["options"]
        }
      )
      $responses << $response
    end
  end
end


escalation "delete_policies" do
  run "delete_applied_policies", data, rs_governance_host, rs_project_id
end

define delete_applied_policies($data, $governance_host, $rs_project_id) return $responses do
 if $param_alert_options != "Email"
    $responses = []
    foreach $item in $data do
      $response = http_request(
        verb: "delete",
        https: true,
        host: $governance_host,
        href: join(["/api/governance/projects/", $rs_project_id, "/applied_policies/", $item["id"]]),
        headers: { "Api-Version": "1.0" }
      )
      $responses << $response
    end
  end
end


